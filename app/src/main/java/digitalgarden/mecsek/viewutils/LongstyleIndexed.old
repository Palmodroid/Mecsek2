package digitalgarden.mecsek.viewutils;

import android.content.ContentValues;
import android.content.Context;
import android.database.Cursor;

import static digitalgarden.mecsek.color.ColorDefsTable.VALUE;
import static digitalgarden.mecsek.database.DatabaseMirror.column;
import static digitalgarden.mecsek.database.DatabaseMirror.table;
import static digitalgarden.mecsek.tables.LibraryDatabase.COLOR_DEFS;
import static digitalgarden.mecsek.viewutils.Longstyle.BOLD_MASK;
import static digitalgarden.mecsek.viewutils.Longstyle.COMPOUND_MASK;
import static digitalgarden.mecsek.viewutils.Longstyle.ITALICS_MASK;

/**
 * This class is only for INDEXED LONGSTYLES!!
 * https://www.fwd.cloud/commit/post/android-context-on-demand/
 * - this is NOT used in multithread enviroment !! -
 */
public class LongstyleIndexed
    {
    // SINGLETON PATTERN WITH CONTEXT ON DEMAND
    private static LongstyleIndexed longstyleIndexed;
    private final Context context;

    private LongstyleIndexed(Context contex)
        {
        this.context = contex.getApplicationContext();
        }

    public static LongstyleIndexed getInstance(Context context)
        {
        if (longstyleIndexed == null)
            longstyleIndexed = new LongstyleIndexed(context);

        return longstyleIndexed;
        }


    // (be careful! database indices start at 1-, while compoundStyleCache indices start at 0-)
    private static final int MAX_INDEX = 64;

    private static long[] compoundStyleCache = new long[MAX_INDEX];
    // Value: 0 (default) not yet pulled
    // Value: -1 already pulled, but not exist in database
    // Value: >0 already pulled and pulled value is cached

    private static int[] inkColorCache = new int[MAX_INDEX]; // Contains also AA bits!!
    private static int[] paperColorCache = new int[MAX_INDEX]; // Contains also AA bits!!
    private static boolean[] boldTextCache = new boolean[MAX_INDEX];
    private static boolean[] italicsTextCache = new boolean[MAX_INDEX];


    /**
     * Check if index is valid.
     * @param databaseIndex
     * @return cache index (if valid) or -1 if index is invalid
     */
    public int checkIndex(long databaseIndex)
        {
        return ( databaseIndex < 1L || databaseIndex > MAX_INDEX ) ? -1 : (int) databaseIndex-1;
        }


    /**
     * Pull indexed longstyle from database
     * @return  cacheIndex - if index is valid, and indexed longstyle exists
     * or       -1         - if index is invalid or
     *                     - indexed longstyle is not yet stored
     */
    private int pullStyle( int cacheIndex )
        {
        // Value not yet pulled - try to pull it
        if ( compoundStyleCache[cacheIndex] == 0L )
            {
            String[] projection = {column(VALUE)}; // One column is enough, id_ is the database cacheIndex (1-256)

            Cursor cursor = context.getContentResolver().query(
                    table(COLOR_DEFS).itemContentUri( cacheIndex + 1 ),    // longstyle == database cacheIndex
                    projection, null, null, null);

            // Queries are never NULL!!!
            if (cursor.moveToFirst())
                {
                // value is pulled
                // store COMPOUND VALUE of this indexed longstyle
                compoundStyleCache[cacheIndex] = cursor.getLong(cursor.getColumnIndex(column(VALUE)));

                inkColorCache[cacheIndex] = calcInkColor( compoundStyleCache[cacheIndex] );
                paperColorCache[cacheIndex] = calcPaperColor( compoundStyleCache[cacheIndex] );
                boldTextCache[cacheIndex] = calcBoldText( compoundStyleCache[cacheIndex] );
                italicsTextCache[cacheIndex] = calcItalicsText( compoundStyleCache[cacheIndex] );
                }
            else
                {
                // This indexed longstyle does not exist,
                // Storing -1L means, that pull was already tried;
                compoundStyleCache[cacheIndex] = -1L;
                }
            cursor.close();
            }

        // Pull already tried - but without success. Previous pull filled up compoundStyleCache with values.
        if ( compoundStyleCache[cacheIndex] < 0L )
            return -1;

        return cacheIndex;
        }


    public long get( int cacheIndex )
        {
        cacheIndex = pullStyle( cacheIndex );
        return cacheIndex < 0 ? 0L : compoundStyleCache[cacheIndex];
        }

    public int getInkColor( int cacheIndex )
        {
        cacheIndex = pullStyle( cacheIndex );
        return cacheIndex < 0 ? Longstyle.DEFAULT_INK_COLOR : inkColorCache[cacheIndex];
        }

    public int getPaperColor( int cacheIndex )
        {
        cacheIndex = pullStyle( cacheIndex );
        return cacheIndex < 0 ? Longstyle.DEFAULT_PAPER_COLOR : paperColorCache[cacheIndex];
        }

    public boolean isBoldText(int cacheIndex )
        {
        cacheIndex = pullStyle( cacheIndex );
        return cacheIndex < 0 ? Longstyle.DEFAULT_BOLD_TEXT : boldTextCache[cacheIndex];
        }

    public boolean isItalicsText(int cacheIndex )
        {
        cacheIndex = pullStyle( cacheIndex );
        return cacheIndex < 0 ? Longstyle.DEFAULT_ITALICS_TEXT : italicsTextCache[cacheIndex];
        }


    /**
     * Generates longstyle from parameters, and stores it
     * in cache[cacheIndex]
     * and in database, too
     */
    private boolean pushStyle( int cacheIndex )
        {
        compoundStyleCache[cacheIndex] = calcLongstyle(
                inkColorCache[cacheIndex],
                paperColorCache[cacheIndex],
                boldTextCache[cacheIndex],
                italicsTextCache[cacheIndex]);

        ContentValues values = new ContentValues();
        values.put( column( VALUE ), compoundStyleCache[cacheIndex] );

        // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        // Ez még nem működik tökéletesen
        // most az insert és update is REPLACE-ként működik.
        // De inkább UPSERT kéne, vagyis INSERT, ha nincs és UPDATE, ha van
        // (Merthogy a relációkat is törli, ha REPLACE)
        // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

        context.getContentResolver().insert(
                table( COLOR_DEFS ).itemContentUri(cacheIndex + 1), values );

        /*
        values.put( column_id(), this.longstyle);

        if ( context.getContentResolver().update(
                table( COLOR_DEFS ).contentUri(), values, null, null) != 1 )
            {
            return false;
            }
        */
        // if successful (one row was updated) store longstyle in the puffer, too
        return true;
        }


    public void setPaperColor( int cacheIndex, int paperColor )
        {
        paperColorCache[cacheIndex] = paperColor;
        pushStyle( cacheIndex );
        }

    public void setInkColor( int cacheIndex, int inkColor )
        {
        inkColorCache[cacheIndex] = inkColor;
        pushStyle( cacheIndex );
        }

    public void setBoldText( int cacheIndex, boolean boldText )
        {
        boldTextCache[cacheIndex] = boldText;
        pushStyle( cacheIndex );
        }

    public void setItalicsText( int cacheIndex, boolean italicsText )
        {
        italicsTextCache[cacheIndex] = italicsText;
        pushStyle( cacheIndex );
        }

    /**
     * Sets style parameters - retaining cacheIndex
     * If it is an indexed style, than corresponding database compoundStyle will be updated
     * @param inkColor
     * @param paperColor
     * @param boldText
     * @param italicsText
     */
    public void set( int cacheIndex, int inkColor, int paperColor, boolean boldText, boolean italicsText )
        {
        inkColorCache[cacheIndex] = inkColor;
        paperColorCache[cacheIndex] = paperColor;
        boldTextCache[cacheIndex] = boldText;
        italicsTextCache[cacheIndex] = italicsText;
        pushStyle( cacheIndex );
        }



    public static int calcInkColor( long longstyle )
        {
        return (int) longstyle | 0xFF000000;           // AA is explicitly solid (0xFF)
        }

    public static int calcPaperColor( long longstyle )
        {
        return (int) (longstyle >> 24) | 0xFF000000; // AA is explicitly solid (0xFF)
        }

    public static boolean calcBoldText( long longstyle )
        {
        return (longstyle & BOLD_MASK) != 0L;
        }

    public static boolean calcItalicsText( long longstyle )
        {
        return (longstyle & ITALICS_MASK) != 0L;
        }

    public static long calcLongstyle( int inkColor, int paperColor, boolean boldText, boolean italicsText )
        {
        //        long longstyle = COMPOUND_MASK |
        //                inkColor | (paperColor << 24) | (boldText ? BOLD_MASK : 0) | (italicsText ? ITALICS_MASK : 0);

        long longstyle =  (paperColor & 0x00FFFFFF);
        longstyle = (longstyle << 24);
        longstyle |= COMPOUND_MASK;
        longstyle |= (inkColor & 0x00FFFFFF);
        longstyle |= (boldText ? BOLD_MASK : 0);
        longstyle |= (italicsText ? ITALICS_MASK : 0);

        return longstyle;
        }

    }
